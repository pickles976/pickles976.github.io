---
layout: post
title: Pose Estimation from Aruco Fiducials in OpenCV
---

![](/images/aruco_post/aruco.jpg)

I have been working through the [SLAM book](https://github.com/gaoxiang12/slambook-en) and also working on building a robot from scratch with some cheap parts as I go. My goal is to learn all the theory behind Monocular Visual SLAM and implement it on my robot.

I started off doing localization from fiducials, which was a concept I got exposed to during my brief stint at Amazon Robotics. The core idea is this: you have some marker, with an ID, that you place in the world. You use some fancy algorithm to detect the marker. Then you can figure out its ID and the pixel coordinates of its four corners. You use the ID to grab the known coordinates of the four corners in 3D. If the camera parameters are known (the pinhole camera matrix, K), then you can figure out the position and rotation of the camera.

In this blog post I want to walk you through that whole process. I will gloss over some of the theory but provide links to the resources you can use if you want to understand the fundamentals. Let's get started with some of the fundamental concepts.

## Requirements

- OpenCV installation and OpenCV with Python
- Access to a Printer
- Basic knowledge of Linear Algebra
- Know what the word "optimization" means

## The Camera Matrix

The first step is going to be "calibrating the camera". Hopefully this image should clarify the problem a bit:

![](/images/aruco_post/intrinsic_extrinsic.jpg)

The intrinsic parameters are what we aim to find in this step. The extrinsic matrix describes the rotation and translation that converts a 3D point from world coordinates to camera coordinates. The intrinsic matrix describes a transformation from 3D camera coordinates, into 2D coordinates of the image. 

The way to do this is to take a lot of pictures of a 3D object with lots of different known points. Given the orientation of those points relative to each other, we can figure out the position of the 3D object relative to our camera. From there it becomes an optimization problem to figure out the intrinsic camera parameters that map the 3D points to 2D. Using a checkerboard pattern is the easiest way to have the relative spacing and orientation of the 3D points be known.

![](/images/aruco_post/calibration.jpg)

If that sounds like a lot of unpleasant math, fear not! OpenCV provides an out of the box solution to calibrating the camera. You can follow the steps below fairly mindlessly and get this piece of puzzle done.

1. Download a calibration image, I use [this one](https://github.com/opencv/opencv/blob/4.x/doc/pattern.png)
2. Print off your calibration image. The scale of the squares is important, you can measure the size of the squares with a pair of calipers or something. You'll want to know their size very precisely in mm.
3. Copy the following code from [GeeksForGeeks](https://www.geeksforgeeks.org/camera-calibration-with-python-opencv/#)
4. Update this line of code:
    objp[0,:,:2] = np.mgrid[0:CHECKERBOARD[0], 0:CHECKERBOARD[1]].T.reshape(-1, 2) * SQUARE_WIDTH
Where SQUARE_WIDTH is the measured value from step 2. This gives your camera matrix a sense of scale. Be aware that all of our measurements are going to be in mm in this tutorial.
5. Take at least 14 pictures of the checkerboard with the camera you want to calibrate. I usually do about 25.
6. Run the script on your images. Images with the corners of the checkerboard hilighted will pop up. You want the corner detections to be accurate. You should delete any images that don't have corners detected, or have them detected improperly.
7. Congratulations! If all things work properly you should see the Camera Matrix and Distortion coefficients. You can save these off to a json and load them later.

Helpful Tip: Take your calibration images at the same aspect ratio and resolution as the images you will take for localization. I ended up burning myself because I was capturing my calibration images for Raspberry Pi camera without using the video port, but then I was using the video port to stream my images during deployment.

## Placing the Fiducials
